/*
 * ZKS Protocol - Tamarin Formal Verification Model (FIXED v5)
 * 
 * Protocol: ZKS (Zero-Knowledge Swarm) Handshake with Mutual Authentication
 * Author: Md. Wasif Faisal, BRAC University
 * Date: December 2025
 * Version: 5.0 - 3-message handshake with key confirmation
 * 
 * KEY FIX: ResponderAccept only fires AFTER receiving a key confirmation
 * message from the initiator that proves they have skI.
 * 
 * Message 1: I -> R: g^ei, senc(<$I, timestamp>, DH(ei, pkR))
 * Message 2: R -> I: g^er, h(<sessionKey, g^er, g^ei, 'responder_auth'>)
 * Message 3: I -> R: h(<g^ei, g^er, sessionKey, 'initiator_confirm'>)
 */

theory ZKS_Handshake
begin

builtins: diffie-hellman, symmetric-encryption, hashing

/*
 * ============================================
 *              KEY INFRASTRUCTURE
 * ============================================
 */

// Long-term keypair generation
rule Generate_Keypair:
    [ Fr(~sk) ]
  -->
    [ !Ltk($A, ~sk), !Pk($A, 'g'^~sk), Out('g'^~sk) ]

// Register expected peers (for mutual authentication)
rule Register_Peer:
    [ !Pk($I, pkI), !Pk($R, pkR) ]
  -->
    [ !ExpectedPeer($R, $I, pkI), !ExpectedPeer($I, $R, pkR) ]

// Reveal long-term keys (for forward secrecy analysis)
rule Reveal_Ltk:
    [ !Ltk(A, sk) ]
  --[ Reveal(A) ]->
    [ Out(sk) ]

/*
 * ============================================
 *   ZKS HANDSHAKE PROTOCOL (3-MESSAGE v5)
 * ============================================
 */

// Message 1: Initiator sends first message
rule Initiator_1:
    let
        EiPk = 'g'^~ei                      // Ephemeral public key
        pkR = 'g'^skR                       // Responder's public key
        k1 = pkR^~ei                        // DH(ei, pkR)
        encryptedId = senc(<$I, ~ts>, k1)   // Encrypted initiator identity
        m1 = <EiPk, encryptedId>
    in
    [ Fr(~ei), Fr(~ts), !Ltk($I, ~skI), !Pk($R, pkR), !ExpectedPeer($I, $R, pkR) ]
  --[ InitiatorStart($I, $R, ~ei) ]->
    [ Out(m1), 
      St_Initiator_1($I, $R, ~skI, ~ei, pkR, ~ts) ]

// Message 2: Responder receives first message, sends response
// NOTE: ResponderAccept is NOT emitted here - only after key confirmation
rule Responder_1:
    let
        EiPk = 'g'^ei
        pkI = 'g'^skI
        ErPk = 'g'^~er
        
        // Key for decryption: DH(ei, skR)
        k1 = EiPk^~skR
        
        // Session key includes both identities
        dh1 = EiPk^~er
        dh2 = EiPk^~skR
        dh3 = pkI^~er
        sessionKey = h(<dh1, dh2, dh3, pkI, 'g'^~skR>)
        
        // Authentication proof for initiator to verify
        authProof = h(<sessionKey, ErPk, EiPk, 'responder_auth'>)
        m2 = <ErPk, authProof>
    in
    [ In(<EiPk, senc(<$I, ts>, k1)>),
      Fr(~er),
      !Ltk($R, ~skR),
      !Pk($I, pkI),
      !ExpectedPeer($R, $I, pkI) ]
  --[ ResponderSentReply($R, $I, sessionKey),
      Honest($I), Honest($R) ]->
    [ Out(m2),
      St_Responder_1($R, $I, ~skR, ~er, EiPk, sessionKey, pkI) ]

// Message 3: Initiator receives response, verifies, sends key confirmation
rule Initiator_2:
    let
        ErPk = 'g'^er
        pkR = 'g'^skR
        pkI = 'g'^~skI
        EiPk = 'g'^~ei
        
        // Session key includes both identities
        dh1 = ErPk^~ei
        dh2 = pkR^~ei
        dh3 = ErPk^~skI
        sessionKey = h(<dh1, dh2, dh3, pkI, pkR>)
        
        // Verify the MAC (must match what responder sent)
        expectedMac = h(<sessionKey, ErPk, EiPk, 'responder_auth'>)
        
        // Key confirmation: proves initiator computed sessionKey (requires skI)
        keyConfirm = h(<EiPk, ErPk, sessionKey, 'initiator_confirm'>)
    in
    [ In(<ErPk, expectedMac>),
      St_Initiator_1($I, $R, ~skI, ~ei, pkR, ts) ]
  --[ InitiatorComplete($I, $R, sessionKey),
      InitiatorConfirmed($I, $R, sessionKey),
      SessionKey($I, $R, sessionKey),
      Honest($I), Honest($R),
      Secret($I, $R, sessionKey) ]->
    [ Out(keyConfirm),
      St_Initiator_2($I, $R, sessionKey) ]

// Message 3 received: Responder verifies key confirmation
// NOW ResponderAccept is emitted - only after proving initiator has skI
rule Responder_2:
    let
        EiPk = 'g'^ei
        pkI = 'g'^skI
        ErPk = 'g'^~er
        
        // Expected key confirmation
        expectedConfirm = h(<EiPk, ErPk, sessionKey, 'initiator_confirm'>)
    in
    [ In(expectedConfirm),
      St_Responder_1($R, $I, ~skR, ~er, EiPk, sessionKey, pkI) ]
  --[ ResponderAccept($R, $I, sessionKey),
      SessionKey($R, $I, sessionKey),
      Honest($I), Honest($R) ]->
    [ St_Responder_2($R, $I, sessionKey) ]

/*
 * ============================================
 *          SECURITY PROPERTIES
 * ============================================
 */

// Secrecy: Session key is secret unless parties are compromised
lemma session_key_secrecy:
  "All I R k #i. 
    Secret(I, R, k) @ i 
    ==> (not Ex #j. K(k) @ j)
        | (Ex #r. Reveal(I) @ r)
        | (Ex #r. Reveal(R) @ r)"

// Authentication: Responder only accepts if initiator genuinely started
// AND sent key confirmation (which requires skI)
lemma initiator_authentication:
  "All R I k #i.
    ResponderAccept(R, I, k) @ i
    ==> (Ex #j. InitiatorConfirmed(I, R, k) @ j & j < i)
        | (Ex #r. Reveal(I) @ r)
        | (Ex #r. Reveal(R) @ r)"

// Injective agreement: Each session key is used only once per party
lemma injective_agreement:
  "All I R k #i #j.
    InitiatorComplete(I, R, k) @ i &
    InitiatorComplete(I, R, k) @ j
    ==> #i = #j"

// Forward secrecy: Key compromise doesn't reveal session key
lemma forward_secrecy:
  "All I R k #i #j.
    SessionKey(I, R, k) @ i &
    K(k) @ j
    ==> (Ex #r. Reveal(I) @ r)
        | (Ex #r. Reveal(R) @ r)"

// Mutual authentication: SessionKey implies both parties are genuine
lemma mutual_authentication:
  "All I R k #i.
    ResponderAccept(I, R, k) @ i & Honest(I) @ i & Honest(R) @ i
    ==> (Ex #j. InitiatorConfirmed(R, I, k) @ j & j < i)
        | (Ex #r. Reveal(I) @ r)
        | (Ex #r. Reveal(R) @ r)"

// Key confirmation chain: ResponderAccept implies InitiatorStart
lemma key_confirmation_chain:
  "All R I k #i.
    ResponderAccept(R, I, k) @ i
    ==> (Ex ei #j. InitiatorStart(I, R, ei) @ j & j < i)
        | (Ex #r. Reveal(I) @ r)
        | (Ex #r. Reveal(R) @ r)"

end

