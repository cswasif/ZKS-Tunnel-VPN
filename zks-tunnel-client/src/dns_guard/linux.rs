//! Linux DNS Configuration
//!
//! Based on Mullvad's talpid-dns/src/linux/
//! Supports systemd-resolved and static /etc/resolv.conf

use std::fs;
use std::net::IpAddr;
use std::path::Path;
use std::process::Command;
use tracing::{debug, info, warn};

type Result<T> = std::result::Result<T, Box<dyn std::error::Error + Send + Sync>>;

pub struct LinuxDnsGuard {
    backup_path: String,
    use_systemd_resolved: bool,
}

impl LinuxDnsGuard {
    pub fn new() -> Result<Self> {
        // Detect if systemd-resolved is running
        let use_systemd_resolved = Command::new("systemctl")
            .args(["is-active", "systemd-resolved"])
            .output()
            .map(|output| output.status.success())
            .unwrap_or(false);

        info!(
            "DNS method: {}",
            if use_systemd_resolved {
                "systemd-resolved"
            } else {
                "/etc/resolv.conf"
            }
        );

        Ok(Self {
            backup_path: "/etc/resolv.conf.zks-backup".to_string(),
            use_systemd_resolved,
        })
    }

    pub async fn set_dns(&mut self, interface_name: &str, dns_servers: Vec<IpAddr>) -> Result<()> {
        if self.use_systemd_resolved {
            self.set_dns_systemd_resolved(interface_name, dns_servers)
                .await
        } else {
            self.set_dns_resolv_conf(dns_servers).await
        }
    }

    pub async fn reset_dns(&mut self) -> Result<()> {
        if self.use_systemd_resolved {
            self.reset_dns_systemd_resolved().await
        } else {
            self.reset_dns_resolv_conf().await
        }
    }

    /// Set DNS using systemd-resolved
    async fn set_dns_systemd_resolved(
        &self,
        interface: &str,
        dns_servers: Vec<IpAddr>,
    ) -> Result<()> {
        info!(
            "Setting DNS via systemd-resolved for interface: {}",
            interface
        );

        // Use resolvectl to set DNS
        let dns_args: Vec<String> = dns_servers.iter().map(|ip| ip.to_string()).collect();

        let output = Command::new("resolvectl")
            .arg("dns")
            .arg(interface)
            .args(&dns_args)
            .output()?;

        if !output.status.success() {
            warn!(
                "resolvectl dns failed: {:?}",
                String::from_utf8_lossy(&output.stderr)
            );
            return Err("Failed to set DNS via resolvectl")?;
        }

        // Set DNS-over-TLS to no (disable DoT for VPN DNS)
        let _ = Command::new("resolvectl")
            .args(["dnsovertls", interface, "no"])
            .output();

        // Set DNSSEC to no (some VPN DNS servers don't support it)
        let _ = Command::new("resolvectl")
            .args(["dnssec", interface, "no"])
            .output();

        info!("✅ DNS set via systemd-resolved");
        Ok(())
    }

    /// Set DNS using /etc/resolv.conf
    async fn set_dns_resolv_conf(&self, dns_servers: Vec<IpAddr>) -> Result<()> {
        info!("Setting DNS via /etc/resolv.conf");

        // Backup original resolv.conf
        if Path::new("/etc/resolv.conf").exists() {
            fs::copy("/etc/resolv.conf", &self.backup_path)?;
            debug!("Backed up /etc/resolv.conf to {}", self.backup_path);
        }

        // Create new resolv.conf with VPN DNS
        let mut content = String::from("# Generated by ZKS VPN\n");
        content.push_str("# DNS leak protection enabled\n\n");

        for server in dns_servers {
            content.push_str(&format!("nameserver {}\n", server));
        }

        // Write to resolv.conf
        fs::write("/etc/resolv.conf", content)?;

        // Make it immutable to prevent other programs from changing it
        let _ = Command::new("chattr")
            .args(["+i", "/etc/resolv.conf"])
            .output();

        info!("✅ DNS set via /etc/resolv.conf");
        Ok(())
    }

    /// Reset DNS using systemd-resolved
    async fn reset_dns_systemd_resolved(&self) -> Result<()> {
        info!("Resetting DNS via systemd-resolved");

        // Revert to default DNS (remove custom settings)
        let _ = Command::new("resolvectl")
            .args(["revert", "tun0"]) // Assuming tun0, should be parameterized
            .output();

        Ok(())
    }

    /// Reset DNS using /etc/resolv.conf
    async fn reset_dns_resolv_conf(&self) -> Result<()> {
        info!("Resetting DNS via /etc/resolv.conf");

        // Remove immutable flag
        let _ = Command::new("chattr")
            .args(["-i", "/etc/resolv.conf"])
            .output();

        // Restore backup if it exists
        if Path::new(&self.backup_path).exists() {
            fs::copy(&self.backup_path, "/etc/resolv.conf")?;
            fs::remove_file(&self.backup_path)?;
            debug!("Restored /etc/resolv.conf from backup");
        }

        Ok(())
    }
}
